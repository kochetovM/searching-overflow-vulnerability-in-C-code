//---------------------------------------------------------------------------
#include <vcl.h>
#pragma hdrstop

#include "Unit1.h"
#include <stdio.h>
#include <stdlib.h>
#include<alloc.h>
#include <string.h>
#include <iostream.h>
#include <conio.h>
#include <fstream.h>
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm1 *Form1;

char directfile[]="C:\\test\\funcdir\\";

FILE* filein;
//ofstream fileout;

const MaxName=100;
const MaxSt=150;
const MaxSLen=50;
const MaxEq=10;
const flagclass=1;
const flagmfunc=0;

int lenstrkv;
int teknumstr=1;

char* tips[5]= {
		 tips[0]="const",
		 tips[1]="char",
                 tips[2]="int",
	       };
const koltips=3;

struct listrezult{
   listrezult* next;
   int nstr;
   int flag;
};

struct listvars{
   listvars* next;
   listvars* equalOP[MaxEq]; //хранит ссылки на ОП, которые происваиваются  которым
   //masiv* m_first; -???
   char name[MaxName];
   char tip[10];
   int len;
   int val;
};

class class_{
   public:
      class_* next;
      char name[MaxName];
      char nameobject[MaxName];
      listvars* lv;
      class_* lobject; //список обьектов
   public:
      int addclass();
      void addop_inclass(class_* rodit,char* s,int flag_uk);
      void makeobject(class_* rodit,char* nameobject);
      void makeobject_instruct(class_* rodit,char* s,int flag_uk);

};
class listformpar{
   public:
      listformpar* next;
      int numb;
      class_* pc;
      listvars* plv;
   public:
      listformpar* add(listformpar* first,listvars* plv2,class_* pc2,int numb2)
      {  numb=numb2;
         pc=pc2;
         plv=plv2;
         next=0;

         listformpar* p=first;
         if(!p) first=this;
         else
         {  while(p->next) p=p->next;
            p->next=this;
         }
         return first;
      }
};
class func {
   public:
      func* next;
      int numberstr;
      int analizflag;
      char name[100];
      listformpar* firstfp; // хранит порядковые номера локальных параметров в списках
      listvars* localv;
      class_* localo;
      FILE* _file;
      FILE* fin;
  public:
    func(char *funcname,class_* pc,listvars* lv,listformpar* p_fp,char* name_c);
    func(func* pf);
    void readfunc_infile();
    void analize();
    func* checkfunc(char* s,char ch,int flag);
    listvars* findOP(char* s,char &ch,int checkfun);
    int checklenght(char* s,char ch,listvars* eq[],int& i);
    int checkdangerfunc(char*s,char ch);
    listvars* checkobject(class_* pc,char* s,char& ch);
    listvars* findobject(class_* pc,char* s,char& ch,int checkfun);
    ~func()
    {  class_* pc;
       listvars* lv;
       listformpar* pfp;

       pc=localo;
       while(pc)
       {  localo=localo->next;
          lv=pc->lv;
          while(lv)
          {  pc->lv=pc->lv->next;
             delete(lv);
             lv=pc->lv;
          }
          delete(pc);
          pc=localo;
       }

       lv=localv;
       while(lv)
       {  localv=localv->next;
          delete(lv);
          lv=localv;
       }

       pfp=firstfp;
       while(pfp)
       {  firstfp=firstfp->next;
          delete(pfp);
          pfp=firstfp;
       }
    }
};

listrezult* firstrez=0;
func* firstfunc=0;
listvars* globalv=0;
class_* firstclass=0;
class_* globalobject=0;

//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
        : TForm(Owner)
{
}
//---------------------------------------------------------------------------
void showfp(listformpar* p)
{

   while(p)
   {  Form1->Memo1->Lines->Add("Параметр функции:");
      Form1->Memo1->Lines->Add(p->numb);
      if(p->plv)
      {  Form1->Memo1->Lines->Add(p->plv->name);
         Form1->Memo1->Lines->Add(p->plv->len);
         Form1->Memo1->Lines->Add(p->plv->val);
      }
      if(p->pc) Form1->Memo1->Lines->Add("Ахтунг!!");

      p=p->next;
   }
}

void showlv(listvars* plv,char* mes)
{
   Form1->Memo1->Lines->Add(mes);
   while(plv)
   {  Form1->Memo1->Lines->Add("______________________ OP _____________________");
      Form1->Memo1->Lines->Add(plv->name);
      Form1->Memo1->Lines->Add(plv->len);
      Form1->Memo1->Lines->Add(plv->val);
      plv=plv->next;
   }
}
void showclass(class_* pc,char* mes,int flag)
{
   Form1->Memo1->Lines->Add(mes);
   while(pc)
   {  Form1->Memo1->Lines->Add("_____________________ class _____________________");
      if(flag) Form1->Memo1->Lines->Add(pc->name);
      else
      {  Form1->Memo1->Lines->Add(pc->name);
         Form1->Memo1->Lines->Add(pc->nameobject);
      }
      showlv(pc->lv,"Список переменных класса:");
      if(flag) showclass(pc->lobject,"Список объектов класса:",0);
      pc=pc->next;
   }
}
void showfunc(func* pf,char* mes)
{  Form1->Memo1->Lines->Add(mes);
   while(pf)
   {  Form1->Memo1->Lines->Add("_____________________ func _____________________");
      Form1->Memo1->Lines->Add(pf->name);
      showlv(pf->localv,"Список переменных функции:");
      showclass(pf->localo,"Список объектов функции:",0);
      pf=pf->next;
   }
}
void showall()
{
   Form1->Memo1->Clear();
   showlv(globalv,"************Список глобальных переменных:***********");
   showclass(globalobject,"**************** Список глобальных объектов: ************",0);
   showclass(firstclass,"**************** Список классов: ************",1);
   showfunc(firstfunc,"****************** СПИСОК ФУНКЦИЙ: ***********");
}

void printerror(char* mesage)
{  /*
   Form1->Memo1->Clear();
   Form1->Memo1->Lines->Append(mesage);
   Form1->Memo1->Lines->Add("Нажмите Выход что бы выйти...");*/
   ShowMessage(mesage);
   exit(0);
   //while(1){ ch=getch();  }
}
//******************************************************************************

class_* checktip(char* s,int& nt)
{
   nt=0;
   while(nt<koltips)
   {   if(!strcmp(tips[nt],s))
       {  nt++;
          return 0;
       }
       nt++;
   }

   nt=0;
   class_* pc=firstclass;
   while(pc!=0)
   {
      if(!strcmp(pc->name,s)) return pc;
      pc=pc->next;
   }
   return 0;
}

char readslovo_str(char *s,char *slovo,int& si)
{
   int kod,i=0;
   char ch;

   while(1)
   {
      ch=s[si++];
      kod=ch;
      if((kod>47)&&(kod<58)) { slovo[i++]=ch; continue; }
      if((kod>64)&&(kod<91)) { slovo[i++]=ch; continue; }
      if((kod>96)&&(kod<123)){ slovo[i++]=ch; continue; }
      if(kod==95) { slovo[i++]=ch; continue; }

      slovo[i]='\0';
      if(ch=='\0')
      {  printerror("Выход за границы массива! в readslovo_str");//Выход за границы массива
      }
      return ch;
   }
}

char readstr_file(FILE* f,char* stroka,int &nstr)
{
   int si=0;
   char ch;
   //while(stroka[si]!='\0') si++;

   while(1)
   {
      ch=fgetc(f);

      if(ch=='\n') nstr++;

      if(ch==';')
      {   //if(!si) printerror();
          stroka[si++]=ch;
          stroka[si]='\0';
          return ch;
      }
      if(ch=='(')
      {  if(!si) printerror("непредвиденный сценарий программы в readstr_file");
         stroka[si]='\0';
         return ch;
      }
      if(ch==')')
      {  stroka[si]='\0';
         return ch;
      }
      if(ch==':')
      {  if(si) stroka[si]='\0';
         return ch;
      }

      if(ch=='"')
      {  stroka[si++]=ch;
         while(1)
         {  ch=fgetc(f);
            if(ch=='\n') nstr++;
            stroka[si++]=ch;
            if(ch=='\\')
            {  ch=fgetc(f);
               if(ch=='\n') nstr++;
               stroka[si++]=ch;
               continue;
            }
            if(ch=='"')  break;
         }
         continue;
      }
      if(ch=='\'') //пропускаем символ
      {  stroka[si++]=ch;
         while(1)
         {  ch=fgetc(f);
            if(ch=='\n') nstr++;
            stroka[si++]=ch;
            if(ch=='\\')
            {  ch=fgetc(f);
               if(ch=='\n') nstr++;
               stroka[si++]=ch;
               continue;
            }
            if(ch=='\'')  break;
         }
         continue;
      }
      if(ch=='/') //пропускаем коментарии
      {  ch=fgetc(f);
         if(ch=='\n') nstr++;
         if(ch=='/')    //
         {  while(ch!='\n')
            { ch=fgetc(f);
              if(ch=='\n') nstr++;
            }
            continue;
         }
         if(ch=='*')    /*  */
         {  while(1)
            {  ch=fgetc(f);
               if(ch=='\n') nstr++;
               if(ch=='*')
               {  ch=fgetc(f);
                  if(ch=='\n') nstr++;
                  if(ch=='/') break;
               }
            }
            continue;
         }
      }

      if((ch!=' ')&&(ch!='\n')) stroka[si++]=ch;
      if(feof(f)) printerror("Неожиданный конец файла в readstr_file");
   }
}
char readslovo_file(FILE* f,char* slovo,int& i,int& nstr)
{
   char ch;
   int kod;
   lenstrkv=0;
   i=0;

   while(1)
   {
      ch=fgetc(f);
      if(feof(f)) return '0';
      kod=ch;

      if((kod>47)&&(kod<58)) { slovo[i++]=ch; continue; }
      if((kod>64)&&(kod<91)) { slovo[i++]=ch; continue; }
      if((kod>96)&&(kod<123)){ slovo[i++]=ch; continue; }
      if(kod==95) { slovo[i++]=ch; continue; }

      if((i==0)&&(ch==' ')) continue;
      if(ch=='\n')
      {  if(i==0)
         {  nstr++;
            continue;
         }
         else nstr++;
      }

      if(ch=='/') //пропускаем коментарии
      {  ch=fgetc(f);
         if(ch=='\n') nstr++;
         if(ch=='/')    //
         {  while(ch!='\n')
            {  ch=fgetc(f);
               if(ch=='\n') nstr++;
            }
            if(i==0) continue;
         }
         if(ch=='*')    /*  */
         {  while(1)
            {  ch=fgetc(f);
               if(ch=='\n') nstr++;
               if(ch=='*')
               {  ch=fgetc(f);
                  if(ch=='\n') nstr++;
                  if(ch=='/') break;
               }
            }
            if(i==0) continue;
         }
      }
      if(ch=='"') //пропускаем строку
      {  while(1)
         {  ch=fgetc(f);
            if(ch=='\n') nstr++;
            if(ch=='\\')
            {  ch=fgetc(f);
               if(ch=='\n') nstr++;
               lenstrkv+=2;
               continue;
            }
            if(ch=='"')  break;
            lenstrkv++;
         }
         if(i) printerror("непредвиденный сценарий программы в readslovo_file");
      }
      if(ch=='\'') //пропускаем символ
      {  while(1)
         {  ch=fgetc(f);
            if(ch=='\n') nstr++;
            if(ch=='\\')
            {  ch=fgetc(f);
               if(ch=='\n') nstr++;
               continue;
            }
            if(ch=='\'')  break;
         }
         if(i==0) continue;
      }

      if(ch=='#')
      {  while(ch!='\n')
         {  ch=fgetc(f);
            if(ch=='\n') nstr++;
         }
         if(i==0) continue;
      }

      if(i) slovo[i]='\0';

      return ch;
   }
}

//*********************************************************************
     //Создание образов переменных:
//*********************************************************************
listvars* addOP(listvars* p,char* name,int nt,int val,int len,int flag_uk)
{
   listvars* first=p;
   if(!p)
   {  p=new listvars;
      first=p;
   }
   else
   {  while(p->next!=0) p=p->next;
      p->next=new listvars;
      p=p->next;
   }

   p->next=0;
   strcpy(p->name,name);
   strcpy(p->tip,tips[2]); //--nt]);
   p->len=len;
   p->val=val;

   for(int i=0;i<MaxEq;i++) p->equalOP[i]=0;

   return first;
}

listvars* findvlistvars(listvars* lv,char* s)
{
   listvars* p=lv;
   while(p)
   {  if(!strcmp(p->name,s)) return p;
      p=p->next;
   }
   return 0;
}

char readOPFromStr(char *s,char *name,int& si,int& len,int& flag_uk)
{
   char ch, s_len[MaxSLen];
   s_len[0]='\0';

   ch=readslovo_str(s,name,si);

   while(ch=='*')
   {  flag_uk=1; //ch=='&' - ?
      ch=readslovo_str(s,name,si);
   }

   if(ch=='[')
   {  ch=readslovo_str(s,s_len,si);
      len=atoi(s_len);
      if(!len)        //если это не число то ищем имя в списке ОП и его значение
      {  listvars* p=0;
         p=findvlistvars(globalv,s_len);
         if(p) len=p->val;
      }

      while((ch!=';')&&(ch!=',')) ch=readslovo_str(s,s_len,si);   // =??

      return ch;
   }

   if(ch=='{')     //??
   {  while(ch!='}') ch=readslovo_str(s,s_len,si);
      ch=readslovo_str(s,s_len,si);
   }

   if(ch=='"')
   {  //si++;
      while(1)
      {  ch=s[si++];
         len++;
         if(ch=='\\')
         {  si++;
            len++;
            continue;
         }
         if(ch=='"') {
         ch=s[si];
         break; }
      }
   }
   if(ch=='\'')
   {  si++;
      while(1)
      {  ch=s[si++];
         len++;
         if(ch=='\\')
         {  si++;
            len++;
            continue;
         }
         if(ch=='\'') { ch=s[si]; break; }
      }
   }

   return ch; // ch=";" либо "," либо "="| nado: "->" "."
   //else print_error(1); //вывод сообщение об ошибке: непредвиденый сценарий

}

listvars* readingOP(listvars* first,char* s,int nt,int flag_uk)
{
   char ch;
   char name[MaxName];
   int si=0, len=0;

   while(1)
   {
      len=0;
      ch=readOPFromStr(s,name,si,len,flag_uk);  //считывание имени переменной

      if(ch==',') //если стоит запятая то добавляем в список ОП новый элемент с именем name и нулевыми атрибутами
      {  if(flag_uk) len=0;
         first=addOP(first,name,nt,0,len,flag_uk);
         flag_uk=0;
         continue;
      }

      if(ch==';')
      {  if(flag_uk) len=0;
         first=addOP(first,name,nt,0,len,flag_uk);
         return first;
      }

      if(ch=='=')
      {  //если "=" то считываем значени которое идет после
         int val=0,index=0,flag_uk2;
         char s_val[30];
                                                       //  int i=k, i[5],p[3]={...}
         ch=readOPFromStr(s,s_val,si,index,flag_uk2);  //считывание значения которое стоит полсе знака равенства
                                                       //здесь index это индекс ячейки, если это массив или длина строки, если это строка
         val=atoi(s_val); //проверяем является ли считаное значение числом
         if(val) // если является, то добавляем ОП
         {  first=addOP(first,name,nt,val,0,flag_uk);
            if(ch==';') return first;    //если конец объявления переменной то выходим из функции
         }
         else        //если это не число, а имя переменной, то ищем имя в списке ОП и его значение
         {  listvars* p=0;
            p=findvlistvars(globalv,s_val); //ищем переменную s_val в списке global
            if(p) first=addOP(first,name,nt,p->val,p->len,flag_uk);  //???
            else first=addOP(first,name,nt,0,index,flag_uk);//если считана строка, то index будет равен ее длине

            if(ch==';') return first;     //если конец объявления переменной то выходим из функции
         }

         if(ch=='=') printerror("непредвиденный сценарий программы 1"); //Вывод ошибки, непредвиденный сценарий программы
         //printerror("Ошибка в readingOP ");
      }
   }
}
listvars* copy_listvars(listvars* plv)
{
   listvars* plv_copy, *first;
   if(plv) first=new listvars;
   else return 0;
   plv_copy=first;
   while(plv)
   {  strcpy(plv_copy->name,plv->name);
      //strcpy(plv_copy->tip,plv->tip);
      plv_copy->len=plv->len;
      plv_copy->val=plv->val;
      plv=plv->next;
      if(plv)
      {  plv_copy->next=new listvars;
         plv_copy=plv_copy->next;
      }
      else plv_copy->next=0;
   }
   return first;
}

void class_::makeobject_instruct(class_* rodit,char* s,int flag_uk)
{
   char ch;
   int si=0,len=0;
   class_* pc=lobject;

   while(1) //копируем объекты класса tc->name до символа ";"
   {
      if(!pc)
      {  lobject=new class_;
         pc=lobject;
      }
      else
      {  while(pc->next) pc=pc->next;
         pc->next=new class_;
         pc=pc->next;
      }
      pc->next=0;

      strcpy(pc->name,rodit->name);
      ch=readOPFromStr(s,pc->nameobject,len,si,flag_uk);  //считывание имени переменной
      pc->lv=rodit->lv;
      pc->lobject=rodit->lobject;

      if(ch==',') continue;

      if(ch==';') return;

      printerror("непредвиденный сценарий программы в makeobject_instruct");
   }
}

void class_::makeobject(class_* rodit,char* s)
{
   strcpy(nameobject,s);
   strcpy(name,rodit->name);
   lobject=rodit->lobject;
   lv=copy_listvars(rodit->lv);
}

//*********************************************************************
     //Считывание функций:
//*********************************************************************
func::func(char *funcname,class_* pc,listvars* lv,listformpar* p_fp,char* name_c)
{
   int len=0;
   char* wayfile;

   next=0;
   numberstr=teknumstr;
   if(name_c==0) strcpy(name,funcname);
   else
   {  if( (strlen(funcname)+strlen(name_c)+1) > MaxSt) printerror("Недостаточный размер массива  в func");
      strcpy(name,name_c);
      strcat(name," ");
      strcat(name,funcname);
   }

   analizflag=0;
   firstfp=p_fp;
   localv=lv;
   localo=pc;

   len=strlen(directfile)+strlen(name)+7;
   if((wayfile=(char*)malloc(len)) == 0) printerror("Недостаточно памяти в func");

   strcpy(wayfile,directfile);
   strcat(wayfile,name);
   strcat(wayfile,".txt");

   _file=fopen(wayfile,"wt");
   if(!_file)
   {  strcat(wayfile,"-Can't open file");
      printerror(wayfile);
   }

   free(wayfile);

}

func::func(func* pf)
{
   strcpy(name,pf->name);
   analizflag=0;
   firstfp=0;
   localv=0;
   localo=0;
   numberstr=pf->numberstr;

   class_* pc1, *pc2;
   listvars* p_lv;
   listformpar *tekfp, *pfp;

   tekfp=pf->firstfp;

   while(tekfp)
   {
      if(tekfp->plv)
      {
         localv=addOP(localv,tekfp->plv->name,1,0,0,0);
         p_lv=localv;
         while(p_lv->next!=0) p_lv=p_lv->next;
         pfp=new listformpar;
         firstfp=pfp->add(firstfp,p_lv,0,tekfp->numb);
      }
      else
      {  if(!tekfp->pc) printerror("Нулевое значение указателя в func");
         pc1=tekfp->pc;
         if(!localo)
         {  localo=new class_;
            pc2=localo;
         }
         else
         {  pc2->next=new class_;
            pc2=pc2->next;
         }
         pc2->next=0;
         strcpy(pc2->name,pc1->name);
         strcpy(pc2->nameobject,pc1->nameobject);
         pc2->lv=0;
         pc2->lobject=pc1->lobject;
         pfp=new listformpar;
         firstfp=pfp->add(firstfp,0,pc2,tekfp->numb);
      }

      tekfp=tekfp->next;
   }
}

void func::readfunc_infile()
{
   int skobka=1;
   char ch;
   numberstr=teknumstr;

   while(skobka)
   {
      ch=fgetc(filein);
      if(feof(filein)) printerror("Конец файла в readfunc_infile()");

      if(ch=='\n') teknumstr++;
      if(ch=='{') skobka++;
      if(ch=='}') skobka--;

      if(ch=='/') //пропускаем коментарии
      {  ch=fgetc(filein);
         if(feof(filein)) printerror("Конец файла в readfunc_infile()");

         if(ch=='/')    //
         {  while(ch!='\n')
            {  ch=fgetc(filein);
               if(ch=='\n')
               {  teknumstr++;
                  fputc(ch,_file);
               }
               if(feof(filein)) printerror("Конец файла в readfunc_infile()");
            }
            continue;
         }
         if(ch=='*')    /*  */
         {  while(1)
            {  ch=fgetc(filein);
               if(ch=='\n')
               {  teknumstr++;
                  fputc(ch,_file);
               }
               if(ch=='*')
               {  ch=fgetc(filein);
                  if(ch=='\n')
                  {  teknumstr++;
                     fputc(ch,_file);
                  }
                  if(ch=='/') break;
               }
            }
            continue;
         }
      }

      fputc(ch,_file);


      if(ch=='"') //пропускаем строку
      {  while(1)
         {  ch=fgetc(filein);
            if(feof(filein)) printerror("Конец файла в readfunc_infile()");
            if(ch=='\n') teknumstr++;

            fputc(ch,_file);
            if(ch=='\\')
            {  ch=fgetc(filein);
               if(ch=='\n') teknumstr++;
               fputc(ch,_file);
               continue;
            }
            if(ch=='"')  break;
         }
      }
      if(ch=='\'') //пропускаем символ
      {  while(1)
         {  ch=fgetc(filein);
            if(ch=='\n') teknumstr++;
            fputc(ch,_file);
            if(ch=='\\')
            {  ch=fgetc(filein);
               if(ch=='\n') teknumstr++;
               fputc(ch,_file);
               continue;
            }
            if(ch=='\'')  break;
         }
      }
   }

   fclose(_file);
}

func* readingFunc(char* name,char* name_c)
{
   char ch='p',*ps;
   char s[MaxSt];
   int numtip,flag_uk=0;
   int kolp=1;
   int si;

   listformpar *pfp,*firstfp;
   class_* tip_struct, *pc;
   class_ *first_c;
   listvars *lv;
   listvars *firstlv;
   func* pf;

   first_c=0;
   firstlv=0;
   firstfp=0;

   while((ch!=';')&&(ch!='{')) //(ch!=')') - ??
   {
      ch=readslovo_file(filein,s,si,teknumstr);
      if(ch=='0') printerror("неожиданый конец файла readingFunc");

      if(ch==',') kolp++;
      if((ch=='*')||(ch=='&')) flag_uk=1;
      else flag_uk=0;

      tip_struct=checktip(s,numtip);
      if((numtip)||(tip_struct))
      {
         /* считывание имени переменной(формального пареметра) */
         si=0;
         do
         {  ch=readslovo_file(filein,s,si,teknumstr);
            if((ch=='*')||(ch=='&')) flag_uk=1;
         }
         while(si==0);

         if(tip_struct)        //если считанный тип есть пользовательский класс
         {  if(!first_c)
            {  first_c=new class_;
               first_c->next=0;
               pc=first_c;
            }
            else
            {  pc=first_c;
               while(pc->next!=0) pc=pc->next;
               pc->next=new class_;
               pc=pc->next;
               pc->next=0;
            }

            //pc->makeobject(tip_struct,s)
            strcpy(pc->name,tip_struct->name);
            strcpy(pc->nameobject,s);
            pc->lv=0;
            pc->lobject=tip_struct->lobject;
            pfp=new listformpar;
            firstfp=pfp->add(firstfp,0,pc,kolp);
         }
         else
         {  firstlv=addOP(firstlv,s,numtip,0,0,flag_uk);
            lv=firstlv;
            while(lv->next!=0) lv=lv->next;
            pfp=new listformpar;
            firstfp=pfp->add(firstfp,lv,0,kolp);
         }
         if(ch==',') kolp++;
      }
   }

   if(ch=='{')
   {  pf=new func(name,first_c,firstlv,firstfp,name_c);
      pf->readfunc_infile();
      return pf;
   }

   if(ch==';')
   {  if(name_c)
      {  pf=new func(name,first_c,firstlv,firstfp,name_c);
         return pf;
      }
      else   //отмена создание объекта, удаляем созданые списки переменнх
      {  pfp=firstfp;
         while(pfp)
         {  firstfp=firstfp->next;
            delete(pfp);
            pfp=firstfp;
         }

         pc=first_c;
         while(pc)
         {  first_c=first_c->next;
            delete(pc);
            pc=first_c;
         }
         lv=firstlv;
         while(lv)
         {  firstlv=firstlv->next;
            delete(lv);
            lv=firstlv;
         }
      }
   }

   return 0;
}
void copy_op(listvars* copy,listvars* plv)
{
   if(!copy) printerror("Нулевое значение указателя 1");
   copy->len=plv->len;
   copy->val=plv->val;
}

listvars* func::checkobject(class_* pc,char* s,char& ch)
{
   int si;
   listvars* op;

   while(pc)
   {
      if(!strcmp(pc->nameobject,s))        //если считано имя объекта
      {
         if(ch==' ') ch=readslovo_file(fin,s,si,numberstr);   //то здесь ожидается: - . , )
         if((ch=='.')||(ch=='-'))
         {  ch=readslovo_file(fin,s,si,numberstr);
            if(ch=='>') ch=readslovo_file(fin,s,si,numberstr);
            if(!si) printerror("Нулевое значение строки 1");

            op=findvlistvars(pc->lv,s); //поиск в списке переменных
            if(op) return op;

            op=checkobject(pc->lobject,s,ch);  //поиск в списке объектов
            if(op) return op;

            /* поиск в списке функций: */
            listvars* plv;
            class_* pc2;
            func* pf=0;
            char bufer[MaxSt];

            strcpy(bufer,pc->name);
            strcat(bufer," ");
            strcat(bufer,s);
            if(flagmfunc) pf=checkfunc(bufer,ch,0);
            if(pf)
            { /* if(pf->localv)
               {  plv=pf->localv;
                  while(plv->next) plv=plv->next;
                  plv->next=pc->lv;
               }
               else localv=pc->lv;

               if(pf->localo)
               {  pc2=pf->localo;
                  while(pc2->next) pc2=pc2->next;
                  pc2->next=pc->lobject;
               }
               else localo=pc->lobject;
                   */
               pf->analize();
               delete(pf);
            }

            return 0;
         }

         if((ch=='s')||(ch==',')||(ch=='(')||(ch==')')) //найдено объявление объекта и возвращается его список lv
         {  op=pc->lv;
            return op;
         }

         printerror("непредвиденный сценарий программы в checkobject");
      }
      pc=pc->next;
   }

   return 0;
}

listvars* func::findobject(class_* pc,char* s,char& ch,int checkfun)
{
   int si;
   listvars* op;

   while(pc)
   {
      if(!strcmp(pc->nameobject,s))        //если считано имя объекта
      {
         if(ch==' ') ch=readslovo_file(fin,s,si,numberstr);
         if((ch=='.')||(ch=='-'))
         {  ch=readslovo_file(fin,s,si,numberstr);
            if(ch=='>') ch=readslovo_file(fin,s,si,numberstr);
            if(!si) printerror("Нулевое значение строки 2");

            op=findvlistvars(pc->lv,s); //поиск в списке переменных
            if(op) return op;

            op=findobject(pc->lobject,s,ch,checkfun);  //поиск в списке объектов
            if(op) return 0;

            if(!checkfun) return 0;

            /* поиск в списке функций: */
            if(flagmfunc)
            {  listvars* plv;
               class_* pc2;
               func* pf=0;
               char bufer[MaxSt];

               strcpy(bufer,pc->name);
               strcat(bufer," ");
               strcat(bufer,s);

              /* if(pf->localv)
               {  plv=pf->localv;
                  while(plv->next) plv=plv->next;
                  plv->next=pc->lv;
               }
               else localv=pc->lv;

               if(pf->localo)
               {  pc2=pf->localo;
                  while(pc2->next) pc2=pc2->next;
                  pc2->next=pc->lobject;
               }
               else localo=pc->lobject;
                       */
               if(pf=checkfunc(bufer,ch,0))
               {  pf->analize();
                  delete(pf);
               }
            }

            return 0;

         }

         return 0;
      }

      pc=pc->next;
   }

   return 0;
}

func* findfunc(char *s)
{
   func* pf=firstfunc;
   while(pf)
   {  if(!strcmp(pf->name,s)) return pf;
      pf=pf->next;
   }
   return 0;
}

func* func::checkfunc(char* s,char ch,int flag)
{
   class_ *pc;
   func *pfunc, *pf, *pf2;
   listvars* plv, *opsave;
   listformpar* tekfp;
   int tekparf,skobka,si;

   pfunc=findfunc(s); // - !strcmp(pfunc1->name,s)

   if(pfunc)   //считываем фактические параметры функции и делаем анализ функции
   {
      if(!strcmp(pfunc->name,name)) return 0;
      if(pfunc->analizflag) return 0;

      pf=new func(pfunc);   //создаем новый объект функции на основе найденого шаблона
      tekfp=pf->firstfp;

      opsave=0;
      tekparf=1;
      skobka=1;
      if(ch!='(') ch=readslovo_file(fin,s,si,numberstr);
      if(ch!='(') printerror("Не встречен символ ( в checkfunc");

      while(skobka)
      {  //считывание параметров функции:
         ch=readslovo_file(fin,s,si,numberstr);
         if(ch=='0') printerror("неожиданый конец файла в checkfunc");

         if(ch=='(')
         {  if(flagmfunc)
            {  if(pf2=checkfunc(s,ch,1)) delete(pf2);
               else skobka++;
            }
            else skobka++;

            continue;
         }
         if(ch==')')
         {  skobka--;
            ch='s';
         }

         if(!tekfp) continue;
         if( si && (tekparf==tekfp->numb))  //копируем атрибуты ОП в ОП функции
         {
            if(tekfp->plv)
            {
               if(lenstrkv)
               {  tekfp->plv->len=lenstrkv;
                  continue;
               }
               plv=findvlistvars(localv,s); //ищем параметр в локальном списке ОП функции
               if(!plv) plv=findvlistvars(globalv,s); //ищем параметр в глобальном списке ОП программы

               if(plv) copy_op(tekfp->plv,plv); //если нашли то копируем атрибуты
               else
               {  opsave=checkobject(localo,s,ch);
                  if(!opsave) opsave=checkobject(globalobject,s,ch);
                  if(opsave) copy_op(tekfp->plv,opsave);
               }
            }
            else
            {
               if(tekfp->pc)
               {  opsave=checkobject(localo,s,ch);
                  if(!opsave) checkobject(globalobject,s,ch);
                  if(opsave) tekfp->pc->lv=copy_listvars(opsave);
                  else //если не найден параметр создаем стандартный набор списка ОП
                  {  pc=firstclass;
                     while(pc)
                     {  if(!strcmp(pc->name,tekfp->pc->name))
                        {  tekfp->pc->lv=copy_listvars(pc->lv);
                           break;
                        }
                        pc=pc->next;
                     }
                  }
               }
            }

         }

         if(ch==')') skobka--;

         if(ch==',')
         {  if(tekparf==tekfp->numb)
            {  tekfp=tekfp->next;
               tekparf++;
            }
            else tekparf++;
         }
      }

      if(flag)
      {  pf->analize();
         pfunc->analizflag=pf->analizflag;
      }
      else pfunc->analizflag=1;

      if(!strcmp(pfunc->name,"copy_listvars"))
      {  ShowMessage("vs");
      }

      return pf;
   }
   else return 0;
}
listvars* func::findOP(char* s,char &ch,int checkfun)
{
   listvars* plv=0;
   if(plv=findvlistvars(localv,s)) return plv;
   if(plv=findvlistvars(globalv,s)) return plv;

   if(plv=findobject(localo,s,ch,checkfun)) return plv;
   if(plv=findobject(globalobject,s,ch,checkfun)) return plv;

   return 0;
}

int func::checklenght(char* s,char ch,listvars* eq[],int& i)
{
   listvars* rez=0;
   int si, skoba;

   for(int j=i;j<MaxEq;j++) eq[j]=0;

   if(ch=='(') skoba=1;
   else skoba=0;
   /*     ищем функцию strlen(): len=strlen(str) + 2;
          ищем функцию maloc(): if((s=(char*)malloc(len+k+2)) == 0)
   */
   i=0;
   if(!strcmp("strlen",s))
   {
      do
      {  si=0;
         while((!si)&&(skoba))
         {  ch=readslovo_file(fin,s,si,numberstr);
            if(ch=='0') printerror("Неожиданый конец файла в checkdangerfunc");
            if(ch=='(') skoba++;
            if(ch==')') skoba--;
         }
         if(ch==')') ch='s';

         if(si) rez=findOP(s,ch,0);
         if(rez) eq[i++]=rez;

         if(ch==')') skoba--;
      }
      while(skoba);
      return 1;
   }

   i=0;
   if(!strcmp("malloc",s))
   {
      listvars* eq2[MaxEq];
      int sum;
      do
      {  si=0;
         sum=0;
         eq2[0]=0;
         rez=0;

         while((!si)&&(skoba))
         {  ch=readslovo_file(fin,s,si,numberstr);
            if(ch=='0') printerror("Неожиданый конец файла в checkdangerfunc");
            if(ch=='(') skoba++;
            if(ch==')') skoba--;
         }


         if(ch=='(')
         {  if(checklenght(s,ch,eq2,sum)) skoba--; }
         else
         {  if(ch==')') ch='s';
            rez=findOP(s,ch,0);
            if(ch==')') skoba--;
         }

         if(rez)
         {  int i2=0;
            while(rez->equalOP[i2])
            {  eq[i++]=rez->equalOP[i2];
               i2++;
            }
            if(!i2) eq[i++]=rez;
         }
         else
           if(eq2[0])
           {  eq[i++]=eq2[0];
              eq2[0]=0;
           }
      }
      while(skoba);
      return 1;
   }

   return 0;
}

void printrezult(char* allfun,listvars* p[],int flag,int nstr,int x1,int x2)
{
   int number=1;

   if(!firstrez)
   {  firstrez=new listrezult;
      firstrez->next=0;
      firstrez->nstr=nstr;
      firstrez->flag=flag;
   }
   else
   {  listrezult* plr=firstrez;
      while(plr)
      {  if(plr->nstr==nstr)
            if(plr->flag==flag) return;
         plr=plr->next;
      }

      plr=firstrez;
      while(plr->next)
      {  plr=plr->next;
         number++;
      }
      plr->next=new listrezult;
      plr=plr->next;
      plr->next=0;
      plr->nstr=nstr;
      plr->flag=flag;
      number++;
   }

   char buf[MaxSt];

   Form1->StringGrid1->RowCount=number+1;

   Form1->StringGrid1->Cells[0][number]=number;
   Form1->StringGrid1->Cells[1][number]=allfun;
   if(p[0])
   {  Form1->StringGrid1->Cells[2][number]=p[0]->name;
      if(p[0]->len) x1=p[0]->len;
      Form1->StringGrid1->Cells[5][number]=x1;
   }
   else Form1->StringGrid1->Cells[2][number]="неизвестен";

   if(p[1])
   {  strcpy(buf,p[1]->name);
      if((p[1]->len)&&(!x2)) x2=p[1]->len;
      for(int i=2;p[i]!=0; i++)
      {  strcat(buf,", ");
         strcat(buf,p[i]->name);
      }
      Form1->StringGrid1->Cells[3][number]=buf;
      Form1->StringGrid1->Cells[6][number]=x2;
   }
   else
   {  Form1->StringGrid1->Cells[3][number]="неизвестен";
      if(x2) Form1->StringGrid1->Cells[6][number]=x2;
   }

   Form1->StringGrid1->Cells[4][number]=nstr;

   if(flag==1) strcpy(buf,"уязвима");
   if(flag==0) strcpy(buf,"безопасна");
   if(flag==2) strcpy(buf,"не известно");
   Form1->StringGrid1->Cells[7][number]=buf;

}


void readuntilskoba(FILE* f,char* s)
{
   int skob=1;
   char ch;
   int i;

   for(i=0;s[i]!='\0';i++)
      if(i>20) printerror("выход за границы строки в readuntilskoba");
   while(skob)
   {  ch=fgetc(f);
      if(feof(f)) printerror("Конец файла в readuntilskoba");
      s[i++]=ch;
      if(i>MaxSt) printerror("выход за границы строки в readuntilskoba");
      if(ch=='(') skob++;
      if(ch==')') skob--;
   }

   s[i]='\0';
}
int func::checkdangerfunc(char*s,char ch)
{
   int skoba,i,flag,len;
   listvars* plv[5];
   int si=0;
   char allfun[MaxSt];
   long curpos;

   for(int j=0;j<5;j++) plv[j]=0;

   if(!strcmp("gets",s))
   {
      curpos = ftell(fin); /* получить текущее положение указателя в файле */
      strcpy(allfun,s);
      if(ch=='(')
      {  skoba=1;
         strcat(allfun,"(");
      }
      else skoba=0;

      readuntilskoba(fin,allfun);
      fseek(fin,curpos, SEEK_SET);   /* восстановить старое положение */

      si=0;
      i=0;
      while(!si)
      {  ch=readslovo_file(fin,s,si,numberstr);
         if(ch=='0') printerror("Неожиданый конец файла в checkdangerfunc");
      }
      plv[i]=findOP(s,ch,0);

      printrezult(allfun,plv,1,numberstr,0,0);//??
      return 1;
   }

   if(!strcmp("sprintf",s))
   {
      curpos = ftell(fin); /* получить текущее положение указателя в файле */
      strcpy(allfun,s);
      if(ch=='(')
      {  skoba=1;
         strcat(allfun,"(");
      }
      else skoba=0;

      readuntilskoba(fin,allfun);
      fseek(fin,curpos, SEEK_SET);   /* восстановить старое положение */

      si=0;
      while(ch!=',')  //считывем первый параметр
      {  ch=readslovo_file(fin,s,si,numberstr);
         if(si) plv[0]=findOP(s,ch,0);
      }
            //пропускаем второй параметр:
      ch=' ';
      while(ch!=',') ch=readslovo_file(fin,s,si,numberstr);

      i=1;
      skoba=1;
      len=0;
      while(skoba)         //считывем третьий параметр
      {  ch=readslovo_file(fin,s,si,numberstr);
         if(lenstrkv) len=lenstrkv;
         if(ch=='0') printerror("Неожиданый конец файла в checkdangerfunc");
         if(si&&(skoba==1))
         {  plv[i]=findOP(s,ch,0);
            if(plv[i]) i++;
         }
         if(ch=='(') skoba++;
         if(ch==')') skoba--;
      }

      /*   Проверяем атрибуты найденых аргументов */
      int x;
      flag=2;

      if((!plv[0])||(!plv[1]))
      {  printrezult(allfun,plv,flag,numberstr,0,0);
         return 1;
      }

      x=0;
      if(len) x+=len;
      for(int j=1;j<i;j++)
      {  if(plv[j]->len) x+=plv[j]->len;
      }

      if(plv[0]->len && x)
      {  if(plv[0]->len < x) flag=1;
         else flag=0;
      }

      printrezult(allfun,plv,flag,numberstr,0,x);
   }

   if( (!strcmp("strcpy",s)) || (!strcmp("strcat",s)) )
   {
      curpos = ftell(fin); /* получить текущее положение указателя в файле */
      strcpy(allfun,s);
      if(ch=='(')
      {  skoba=1;
         strcat(allfun,"(");
      }
      else skoba=0;

      readuntilskoba(fin,allfun);
      fseek(fin,curpos, SEEK_SET);   /* восстановить старое положение */

      len=0;
      i=0;
      do
      {  si=0;
         while((!si)&&(skoba))
         {  ch=readslovo_file(fin,s,si,numberstr);

            if(lenstrkv) len=lenstrkv;
            if(ch=='0') printerror("Неожиданый конец файла в checkdangerfunc");
            if(ch=='(') skoba++;
            if(ch==')') skoba--;
         }
         if(ch==')') ch='s';
         if(si) plv[i++]=findOP(s,ch,0);
         if(ch==')') skoba--;
      }
      while(skoba);

      /* сравниваем атрибуты считанных ОП */
      flag=2;
      int val1=0, val2=0;
      int len1=0, len2=0;
      int x1=0, x2=0;

      if(plv[0])
        if((plv[0]->len!=0)&&(len))
        {   if(plv[0]->len < len) flag=1;
            else flag=0;
            //ShowMessage(len);
            //showlv(localv,"Список оп:");
            printrezult(allfun,plv,flag,numberstr,0,len);
            return 1;
        }

      if((!plv[0])||(!plv[1]))
      {  printrezult(allfun,plv,flag,numberstr,0,0);
         return 1;
      }

      if((plv[0]->len!=0)&&(plv[1]->len!=0))
      {  if(plv[0]->len < plv[1]->len) flag=1;
         else flag=0;
      }
      else
      {  i=0;
         if(plv[0]->len==0)
         {  while(plv[0]->equalOP[i]!=0)
            {  if(!strcmp(plv[0]->equalOP[i]->name,plv[1]->name))
               {  flag=0;
                  break;
               }
               else
               {  val1+=plv[0]->equalOP[i]->val;
                  len1+=plv[0]->equalOP[i]->len;
               }
               i++;
            }
         }
         i=0;
         if(plv[1]->len==0)
         {  while(plv[1]->equalOP[i]!=0)
            {  if(!strcmp(plv[1]->equalOP[i]->name,plv[0]->name))
               {  flag=0;
                  break;
               }
               else
               {  val2+=plv[1]->equalOP[i]->val;
                  len2+=plv[1]->equalOP[i]->len;
               }
               i++;
            }
         }

         if(flag==2)
         {
            x1=0,x2=0;

            if(plv[0]->len) x1=plv[0]->len;
            else
            {  if(len1) x1=len1;
               else x1=val1;
            }

            if(plv[1]->len) x2=plv[1]->len;
            else
            {  if(len2) x2=len2;
               else x2=val2;
            }

            if(x1 && x2)
            {  if(x1<x2) flag=1;
               else flag=0;
            }
         }
      }

      printrezult(allfun,plv,flag,numberstr,x1,x2);
      return 1;
   }

   return 0;
}

void func::analize()
{
   char ch;
   char s[MaxSt];
   char bufer[MaxSt];

   strcpy(bufer,directfile);
   strcat(bufer,name);
   strcat(bufer,".txt");
   fin=fopen(bufer,"rt");
   if(!fin)
   {  strcat(bufer," - Не найден файл");
      printerror(bufer);
   }

   analizflag=1;

   class_* tip_struct, *pc;
   listvars *plv, *plv2;
   func* pf;
   int val,skobka,si,numtip,len=0,flag_uk=0;

   while(1)
   {
      ch=readslovo_file(fin,s,si,numberstr); //считываем  слово(единицу инструкции) исходного кода из файла и подвергаем ее анализу
      if(ch=='0') break;

      tip_struct=checktip(s,numtip); //проверяем на принадлежность типу считаного слова
      if((numtip)||(tip_struct))
      {
         ch=readstr_file(fin,s,numberstr);  //считываем имена переменных в строку пока не встретим символ ; или (

         if(ch==';') //если счтаная инструкция заканчивается ; значит шло объявление переменных
         {  if(tip_struct)        //если считанный тип есть пользовательский класс
            {  pc=localo;
               if(!pc)
               {  localo=new class_;
                  pc=localo;
               }
               else
               {  while(pc->next) pc=pc->next;
                  pc->next=new class_;
                  pc=pc->next;
               }
               pc->next=0;
               si=0;
               int whileflag=1;
               while(whileflag)
               {  ch=readOPFromStr(s,bufer,si,len,flag_uk);  //считывание имени переменной
                  pc->makeobject(tip_struct,bufer); //счтывание объекта класса(ОП) и его данных
                  if(ch==',')
                  {  pc->next=new class_;
                     pc=pc->next;
                     pc->next=0;
                     continue;
                  }
                  whileflag=0;
               }
            }
            else
            {
               localv=readingOP(localv,s,numtip,0);  //счтывание переменной(ОП) и ее данных
            }

            continue;
         }
      }

      if(ch=='(')
      {  if(flagmfunc)  //ищем в списке функций функцию с именем s и делаем ее анализ
         {  if(pf=checkfunc(s,ch,1))
            {  delete(pf);
               continue;
            }
         }

         if(checkdangerfunc(s,ch))
         {  if(firstfp) analizflag=0;
            continue;
         }
      }

      plv=findOP(s,ch,1);
      if(plv)
      {  if(ch==' ') ch=readslovo_file(fin,s,si,numberstr);

         if(ch=='=')  //считываем равенство по правую сторону
         {  skobka=1;
            int sum=0;
            for(int i=0;i<MaxEq;i++) plv->equalOP[i]=0;
            while((ch!=';')&&(skobka))
            {  s[0]='\0';
               ch=readslovo_file(fin,s,si,numberstr);
               if(ch=='=') break;          //if(len==k)???
               if(lenstrkv)
               {  plv->len=lenstrkv;
                  break;
               }

               if((ch=='(')&&(si==0))
               {  skobka++;
                  continue;
               }
               if(ch==')')
               {  skobka--;
                  continue;
               }               //if(s[0]!='\0'): скобка не считается
               if(s[0]!='\0')  //ищем функции maloc strlen или ОП
               {                            //len= ( strlen ( str)) + (strlen(str)))
                  if(!checklenght(s,ch,plv->equalOP,sum))          //len = str;  len= b->str; len=b.func();
                  {
                     if(flagmfunc) pf=checkfunc(s,ch,1);
                     else pf=0;

                     if(!pf)
                     {  if(!checkdangerfunc(s,ch))
                        {  if(plv2=findOP(s,ch,1)) copy_op(plv,plv2);
                           else
                           {  val=atoi(s);
                              if(val) plv->val=val;
                           }
                           if(ch=='(') skobka++;
                           if(ch==')') skobka--;
                        }
                        else
                        {  if(firstfp) analizflag=0;
                           break;
                        }
                     }
                     else
                     {  delete(pf);
                        break;
                     }

                  }
               }

            }
         }
      }
   }

   fclose(fin);
}

//----------------------------------------------------------------------------
//      ---------------    Анализ класса и структур  ---------------
//----------------------------------------------------------------------------

int class_::addclass()
{
   /* считываем  переменные в кллассе или структуре
      если есть функции то сохраняем их в один файл
      члены класса храним в специальном списке,
      со структурой: */

   char ch, s[MaxSt];
   char* ps[5];
   int len_s,im;
   int flag_uk,numtip;
   int si;
   class_ *tip_struct;
   func* pf,*pf2;
//   class_* pr,*pr2;

   next=0;
   lv=0;
   lobject=0;
   name[0]='\0';
   im=0;

   for(int i=0;i<5;i++) ps[i]=0;

   ch=readslovo_file(filein,name,si,teknumstr);  //считываем имя класса
   if(si==0) return 0; //printerror("непредвиденный сценарий программы 3");

   if(ch==' ') ch=readslovo_file(filein,name,si,teknumstr);

   if(ch==':')
      while((ch!='{')&&(ch!=';')) ch=readslovo_file(filein,name,si,teknumstr);

   if(ch=='{')  //считывание членов класса
   {
      while(ch!='}')
      {
         flag_uk=0;
         ch=readslovo_file(filein,s,si,teknumstr);
         if(ch=='0') printerror("Неожиданный конец файла 1");

         tip_struct=checktip(s,numtip); //проверяем на принадлежность типу считаного слова

         if(tip_struct)
         {  if(!strcmp(tip_struct->name,name))
            {  ch=readstr_file(filein,s,teknumstr);
               if(ch==';')
               {  // выделить память под строку
                  len_s=strlen(s);
                  if((ps[im]=(char*)malloc(len_s+2)) == 0) printerror("Недостаточно памяти");
                  strcpy(ps[im],s);   // копируем s
                  im++;
               }
               //else printerror(s); //"Не предвиденый сценарий программы 8");
               tip_struct=0;
            }
         }
         if((numtip)||(tip_struct))
         {
            if((ch=='*')||(ch=='&')) flag_uk=1;

            ch=readstr_file(filein,s,teknumstr);  //считываем имена переменных

            if(ch==';') //если счтаная инструкция заканчивается ; значит шло объявление переменных
            {
               if(tip_struct)        //считывание объекта класса
               {
                  this->makeobject_instruct(tip_struct,s,flag_uk);
               }
               else
               {
                  lv=readingOP(lv,s,numtip,flag_uk);  //счтывание переменной(ОП) и ее данных
               }
            }
         }
         if(ch=='(')
         {  pf=readingFunc(s,name);
            if(!firstfunc) firstfunc=pf;
            else
            {  pf2=firstfunc;
               while(pf2->next!=0) pf2=pf2->next;
               pf2->next=pf;
            }
            continue;
         }
      }

      if(im)
      {
         for(int i=0;i<im;i++)
         {   makeobject_instruct(this,ps[i],0);
             free(ps[i]);
         }
      }

      return 1;
   }

   return 0;
}

//*********************************************************************
     //Считывание данных из файла,межпроцедурный анализ функций:
//*********************************************************************

void readfile()
{
   char s[MaxSt],ch;
   char bufer[MaxSt];
   int flag_uk, numtip, si, len;
   class_ *tip_struct, *pc;
   func *pf, *pf2;

   while(1)
   {
      flag_uk=0;
      ch=readslovo_file(filein,s,si,teknumstr); //считываем  слово(единицу инструкции) исходного кода из файла и подвергаем ее анализу
      if(ch=='0') break;

      tip_struct=checktip(s,numtip); //проверяем на принадлежность типу считаного слова
      if((numtip)||(tip_struct))
      {
         if((ch=='*')||(ch=='&')) flag_uk=1;
         ch=readstr_file(filein,s,teknumstr);  //считываем имена переменных в строку пока не встретим символ ; или (

         if(ch==';') //если счтаная инструкция заканчивается ; значит шло объявление переменных
         {  if(tip_struct)        //если считанный тип есть пользовательский класс
            {
               pc=globalobject;
               if(!pc)
               {  globalobject=new class_;
                  pc=globalobject;
               }
               else
               {  while(pc->next) pc=pc->next;
                  pc->next=new class_;
                  pc=pc->next;
               }
               pc->next=0;
               while(1)
               {  ch=readOPFromStr(s,bufer,len,si,flag_uk);  //считывание имени переменной
                  pc->makeobject(tip_struct,bufer); //счтывание объекта класса(ОП) и его данных
                  if(ch==',')
                  {  pc->next=new class_;
                     pc=pc->next;
                     pc->next=0;
                     continue;
                  }
                  if(ch==';') break;
                  printerror("непредвиденный сценарий программы 2");//-nugno dorabotat!
               }
            }
            else
            {
               globalv=readingOP(globalv,s,numtip,flag_uk);  //счтывание переменной(ОП) и ее данных
            }
         }
         if(ch==':')
         {  //ищем в списке классов елемнт с именем s и затем считываем из файла его член-функцию
            strcpy(bufer,s);
            ch=readslovo_file(filein,s,si,teknumstr);
            if(ch==':')  ch=readslovo_file(filein,s,si,teknumstr);
            strcat(bufer," ");
            strcat(bufer,s);

            int flagf=0;
            pf=firstfunc;
            while(pf)
            {  if(!strcmp(pf->name,bufer))
               {  flagf=1;
                  while(ch!='{')
                  {  ch=readslovo_file(filein,s,si,teknumstr);
                     if(ch==';') printerror("непредвиденный сценарий программы readfile 1");
                  }
                  pf->readfunc_infile();
                  break;
               }
               pf=pf->next;
            }
            //if(!pf) printerror("непредвиденный сценарий программы readfile 2");

            if(flagf) continue;
         }
      }

      if(ch=='(')
      {  pf=readingFunc(s,0);
         if(!firstfunc) firstfunc=pf;
         else
         {  pf2=firstfunc;
            while(pf2->next!=0) pf2=pf2->next;
            pf2->next=pf;
         }
         continue;
      }

      if( ((!strcmp(s,"class"))||(!strcmp(s,"struct"))) && (flagclass) )
      {  if(!firstclass)
         {  firstclass=new class_;
            pc=firstclass;
         }
         else
         {  pc=firstclass;
            while(pc->next!=0) pc=pc->next;
            pc->next=new class_;
            pc=pc->next;
         }

         if(!pc->addclass()) //если класс не создан, то удаляем созданный объект
         {  if(!firstclass->next)
            {  delete(firstclass);
               firstclass=0;
            }
            else
            {  pc=firstclass;
               while(pc->next->next!=0) pc=pc->next;
               delete(pc->next);
               pc->next=0;
            }
         }
         else
         {  while(ch!=';')
            {
               ch=readslovo_file(filein,s,si,teknumstr);
               if(si)
               {  class_ *pc2;
                  pc2=globalobject;
                  if(!pc2)
                  {  globalobject=new class_;
                     pc2=globalobject;
                  }
                  else
                  {  while(pc2->next) pc2=pc2->next;
                     pc2->next=new class_;
                     pc2=pc2->next;
                  }
                  pc2->next=0;
                  pc2->makeobject(pc,s);
               }
            }
         }


      }
   }

   fclose(filein);
}

void AutoSizeGridColumn()
{
   int  temp, max;
   for(int column=0;column<Form1->StringGrid1->ColCount;column++)
   {  max= 0;
      for(int i=0;i<Form1->StringGrid1->RowCount;i++)
      {  temp=Form1->StringGrid1->Canvas->TextWidth(Form1->StringGrid1->Cells[column][i]);
         if(temp > max) max=temp;
      }
      Form1->StringGrid1->ColWidths[column]=max + Form1->StringGrid1->GridLineWidth + 20;
   }
}
void __fastcall TForm1::Button1Click(TObject *Sender)
{
   if(Form1->OpenDialog1->Execute())
   {  Form1->Edit1->Text=&Form1->OpenDialog1->FileName[1];
      filein=fopen(&Form1->OpenDialog1->FileName[1],"rt");
      if(!filein) printerror("No such file");
   }
   else return;

   //filein=fopen("C:\\test\\1.txt","rt");
   //if(!filein) printerror("No such file");

   readfile();

   func* pf;
   if(flagmfunc)
   {  pf=findfunc("main");
      if(pf) pf->analize();
      else printerror("Не найдена функция main()");
   }
   else
   {  pf=firstfunc;
      while(pf)
      {  pf->analize();
         pf=pf->next;
      }
   }

   AutoSizeGridColumn();

   /* удаление файлов */
   char fname[MaxSt];
   pf=firstfunc;
   while(pf)
   {  strcpy(fname,directfile);
      strcat(fname,pf->name);
      strcat(fname,".txt");
      remove(fname);
      pf=pf->next;
   }
   //showall();
}

void __fastcall TForm1::FormActivate(TObject *Sender)
{
   Form1->StringGrid1->Cells[0][0]="№";
   Form1->StringGrid1->Cells[1][0]="функция";
   Form1->StringGrid1->Cells[2][0]="аргумент 1";
   Form1->StringGrid1->Cells[3][0]="аргумент 2";
   Form1->StringGrid1->Cells[4][0]="№ стр.";
   Form1->StringGrid1->Cells[5][0]="длина арг.1";
   Form1->StringGrid1->Cells[6][0]="длина арг.2";
   Form1->StringGrid1->Cells[7][0]="оценка уязвимости";
}

